{"version":3,"file":"rete-engine.min.js","sources":["../src/engine/component.js","../src/core/events.js","../src/core/emitter.js","../src/core/validator.js","../src/core/context.js","../src/engine/events.js","../src/engine/index.js"],"sourcesContent":["export class Component {\n    constructor(name) {\n        if (this.constructor === Component)\n            throw new TypeError('Can not construct abstract class.');\n        \n        this.name = name;\n        this.data = {};\n        this.engine = null;\n    }\n\n    worker() { }\n}","export class Events {\n\n    constructor(handlers) {\n        this.handlers = {\n            warn: [console.warn],\n            error: [console.error],\n            ...handlers\n        };\n    }    \n}","import { Events } from './events';\n\nexport class Emitter {\n\n    constructor(events: Events | Emitter) {\n        this.events = events instanceof Emitter ? events.events : events.handlers;\n        this.silent = false;\n    }\n\n    on(names: string, handler: () => {}) {\n        names.split(' ').forEach(name => {\n            if (!this.events[name])\n                throw new Error(`The event ${name} does not exist`);\n            this.events[name].push(handler);\n        });\n\n        return this;\n    }\n\n    trigger(name: string, params) {\n        if (!(name in this.events))\n            throw new Error(`The event ${name} cannot be triggered`);\n\n        return this.events[name].reduce((r, e) => {\n            return (e(params) !== false) && r\n        }, true); // return false if at least one event is false        \n    }\n\n    bind(name: string) {\n        this.events[name] = [];\n    }\n}","export class Validator {\n\n    static isValidData(data) {\n        return typeof data.id === 'string' &&\n            this.isValidId(data.id) &&\n            data.nodes instanceof Object && !(data.nodes instanceof Array);\n    }\n\n    static isValidId(id) {\n        return /^[\\w-]{3,}@[0-9]+\\.[0-9]+\\.[0-9]+$/.test(id);\n    }\n\n    static validate(id, data) {\n        var msg = '';\n        var id1 = id.split('@');\n        var id2 = data.id.split('@');\n\n        if (!this.isValidData(data))\n            msg += 'Data is not suitable. '; \n        if (id !== data.id)\n            msg += 'IDs not equal. ';\n        if (id1[0] !== id2[0])\n            msg += 'Names don\\'t match. ';\n        if (id1[1] !== id2[1])\n            msg += 'Versions don\\'t match';\n\n        return { success: msg ==='', msg };\n    }\n}","import { Emitter } from './emitter'\nimport { Validator } from './validator'\n\nexport class Context extends Emitter {\n\n    constructor(id, events) {\n        super(events);\n\n        if (!Validator.isValidId(id))\n            throw new Error('ID should be valid to name@0.1.0 format');  \n        \n        this.id = id;\n    }\n\n    use(plugin, options = {}) {\n        plugin.install(this, options);\n    }\n}","import { Events } from '../core/events';\n\nexport class EngineEvents extends Events {\n\n    constructor() {\n        super({\n            componentregister: []\n        });\n    }    \n}","import { Component } from './component';\nimport { Context } from '../core/context';\nimport { EngineEvents } from './events';\nimport { Validator } from '../core/validator';\n\nvar State = { AVALIABLE:0, PROCESSED: 1, ABORT: 2 };\n\nexport { Component };\n\nexport class Engine extends Context {\n\n    constructor(id: string) {\n        super(id, new EngineEvents());\n\n        this.components = [];\n        this.args = [];\n        this.data = null;\n        this.state = State.AVALIABLE;\n        this.onAbort = () => { };\n    }\n\n    clone() {\n        const engine = new Engine(this.id);\n\n        this.components.map(c => engine.register(c));\n\n        return engine;\n    }\n\n    register(component: Component) {\n        this.components.push(component);\n        this.trigger('componentregister', component);\n    }\n\n    async throwError (message, data = null) {\n        await this.abort();\n        this.trigger('error', { message, data });\n        this.processDone();\n\n        return 'error';\n    }\n\n    extractInputNodes(node, nodes) {\n        return Object.keys(node.inputs).reduce((a, key) => {\n            return [...a, ...(node.inputs[key].connections || []).reduce((b, c) => [...b, nodes[c.node]], [])]\n        }, []);\n    }\n\n    detectRecursions(nodes) {\n        const nodesArr = Object.keys(nodes).map(id => nodes[id]);\n        const findSelf = (node, inputNodes) => {\n            if (inputNodes.some(n => n === node))\n                return node;\n            \n            for (var i = 0; i < inputNodes.length; i++) {\n                if (findSelf(node, this.extractInputNodes(inputNodes[i], nodes)))\n                    return node;\n            }\n\n            return null;\n        }\n\n        return nodesArr.map(node => {\n            return findSelf(node, this.extractInputNodes(node, nodes))\n        }).filter(r => r !== null);\n    }\n\n    processStart() {\n        if (this.state === State.AVALIABLE) {  \n            this.state = State.PROCESSED;\n            return true;\n        }\n\n        if (this.state === State.ABORT) {\n            return false;\n        }\n\n        console.warn(`The process is busy and has not been restarted.\n                Use abort() to force it to complete`);\n        return false;\n    }\n\n    processDone() {\n        var success = this.state !== State.ABORT;\n\n        this.state = State.AVALIABLE;\n        \n        if (!success) {\n            this.onAbort();\n            this.onAbort = () => { }\n        }    \n\n        return success;\n    }\n\n    async abort() {\n        return new Promise(ret => {\n            if (this.state === State.PROCESSED) {\n                this.state = State.ABORT;\n                this.onAbort = ret;\n            }\n            else if (this.state === State.ABORT) {\n                this.onAbort();\n                this.onAbort = ret;\n            }\n            else\n                ret();\n        });\n    }\n\n    async lock(node) {\n        return new Promise(res => {\n            node.unlockPool = node.unlockPool || [];\n            if (node.busy && !node.outputData)\n                node.unlockPool.push(res);\n            else \n                res();\n            \n            node.busy = true;\n        });    \n    }\n\n    unlock(node) {\n        node.unlockPool.forEach(a => a());\n        node.unlockPool = [];\n        node.busy = false;\n    }\n\n    async extractInputData(node) {\n        const obj = {};\n\n        for (let key of Object.keys(node.inputs)) {\n            let input = node.inputs[key];\n            var conns = input.connections;\n            let connData = await Promise.all(conns.map(async (c) => {\n                const prevNode = this.data.nodes[c.node];\n\n                let outputs = await this.processNode(prevNode);\n\n                if (!outputs) \n                    this.abort();\n                else\n                    return outputs[c.output];\n            }));\n\n            obj[key] = connData;\n        }\n\n        return obj;\n    }\n\n    async processWorker(node) {\n        var inputData = await this.extractInputData(node);\n        var component = this.components.find(c => c.name === node.name);\n        var outputData = {};\n\n        try {\n            await component.worker(node, inputData, outputData, ...this.args);\n        } catch (e) {\n            this.abort();\n            this.trigger('warn', e);\n        }\n\n        return outputData;\n    }\n\n    async processNode(node) {\n        if (this.state === State.ABORT || !node)\n            return null;\n        \n        await this.lock(node);\n\n        if (!node.outputData) {\n            node.outputData = this.processWorker(node)\n        }\n\n        this.unlock(node);\n        return node.outputData;\n    }\n\n    async forwardProcess(node) {\n        if (this.state === State.ABORT)\n            return null;\n\n        return await Promise.all(Object.keys(node.outputs).map(async (key) => {\n            const output = node.outputs[key];\n\n            return await Promise.all(output.connections.map(async (c) => {\n                const nextNode = this.data.nodes[c.node];\n\n                await this.processNode(nextNode);\n                await this.forwardProcess(nextNode);\n            }));\n        }));\n    }\n\n    copy(data) {\n        data = Object.assign({}, data);\n        data.nodes = Object.assign({}, data.nodes);\n        \n        Object.keys(data.nodes).forEach(key => {\n            data.nodes[key] = Object.assign({}, data.nodes[key])\n        });\n        return data;\n    }\n\n    async validate(data) {\n        var checking = Validator.validate(this.id, data);\n\n        if (!checking.success)\n            return await this.throwError(checking.msg);  \n        \n        var recurentNodes = this.detectRecursions(data.nodes);\n\n        if (recurentNodes.length > 0)\n            return await this.throwError('Recursion detected', recurentNodes);      \n         \n        return true;\n    }\n\n    async processStartNode(id) {\n        if (id) {\n            let startNode = this.data.nodes[id];\n\n            if (!startNode)\n                return await this.throwError('Node with such id not found');   \n            \n            await this.processNode(startNode);\n            await this.forwardProcess(startNode);\n        }\n    }\n\n    async processUnreachable() {\n        for (var i in this.data.nodes) // process nodes that have not been reached\n            if (typeof this.data.nodes[i].outputData === 'undefined') {\n                var node = this.data.nodes[i];\n\n                await this.processNode(node);\n                await this.forwardProcess(node);\n            }\n    }\n\n    async process(data: Object, startId: ?number = null, ...args) {\n        if (!this.processStart()) return;\n        if (!this.validate(data)) return;    \n        \n        this.data = this.copy(data);\n        this.args = args;\n\n        await this.processStartNode(startId);\n        await this.processUnreachable();\n        \n        return this.processDone()?'success':'aborted';\n    }\n}"],"names":["Component","name","this","constructor","TypeError","data","engine","Events","handlers","console","warn","error","Emitter","events","silent","names","handler","split","forEach","_this","Error","push","params","reduce","r","e","Validator","id","isValidId","nodes","Object","Array","test","msg","id1","id2","isValidData","success","Context","plugin","options","install","EngineEvents","State","Engine","components","args","state","onAbort","map","register","c","component","trigger","message","abort","processDone","node","keys","inputs","a","key","connections","b","nodesArr","findSelf","inputNodes","some","n","i","length","_this2","extractInputNodes","filter","Promise","_this3","ret","unlockPool","busy","outputData","res","input","all","conns","_this4","processNode","prevNode","outputs","output","connData","obj","extractInputData","find","worker","inputData","lock","processWorker","unlock","_this5","nextNode","forwardProcess","assign","validate","throwError","checking","detectRecursions","recurentNodes","startNode","startId","processStart","copy","processStartNode","processUnreachable"],"mappings":"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"}